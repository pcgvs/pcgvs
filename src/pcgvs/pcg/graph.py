import numpy as np

from typing import List
from pcgvs.extraction import Tube
from pcgvs.pcg.relations import Intersection, Overlapping, RelationsMap


class Node: 

    def __init__(self, id: str, tube: Tube, frame=None):
        self.id = id
        self.tube = tube
        self.color = None 
        self.frame = frame

    def is_mainnode(self) -> bool: 
        return self.frame is None

    def is_subnode(self) -> bool:
        return self.frame is not None

#---------------------------------------#
#---------------------------------------#
#---------------------------------------#


class PCG:
    
    def __init__(self, tubes: List[Tube], relations: RelationsMap):
        self.tubes = tubes
        self.relations = relations
        self.nodes = {}
        self.edges = {}
        self.A = {}
        self._build_graph()
        

    def uncolored_nodes(self) -> List[str]:
        return [ k for k, v in self.nodes.items() if v.color is None ]
    

    def node(self, key) -> Node:
        return self.nodes[key]
    

    def generated_by_intersection(self, key: str) -> bool:
        return len(key.split('-')) == 2
    

    def generated_by_overlapping(self, key:str) -> bool:
        return len(key.split('-')) == 3    
    

    def identify_quatern(self, key) -> tuple:
        """ Given a subnode generated by an overlapping, returns (vs, ve, vsp, vep) where:
            - vs is the node corresponding to the overlapping start in the tube of key
            - ve is the node corresponding to the overlapping end in the tube of key
            - vsp is the node corresponding to the overlapping start in the other tube
            - vep is the node corresponding to the overlapping end in the other tube
        """
        if self.generated_by_intersection(key): 
            raise Exception('cannot identify quatern on intersection generated subnodes.')
        fr, to, _ = key.split('-')
        vs  = f'{fr}-{to}-s'
        ve  = f'{fr}-{to}-e'
        vsp = f'{to}-{fr}-s'
        vep = f'{to}-{fr}-e'
        return vs, ve, vsp, vep


    def identify_opposite(self, key:str) -> str:
        """ Given a subnode generated by overlapping, returns the opposite node.
            If the node is the starting one, the method returns the ending one, and viceversa.
        """
        if self.generated_by_intersection(key): 
            raise Exception('cannot identify opposite on intersection generated subnodes.')
        
        ex = 'e' if key[-1] == 's' else 's' 
        
        return key[:-1] + ex
        
    
    def adjacents(self, key) -> List[str]:
        if key not in self.nodes: return None
        return [ (k, v) for k, v in self.nodes.items() if self.A[key][k] != 0 ]
        
    
    def clean_colors(self):
        for v in self.nodes.values():
            v.color = None
    

    def _build_graph(self):
        
        edges_list = []
        rmap = self.relations.as_dict()
    
        for tube in self.tubes:
            tube_relations = rmap[tube.tag]
            
            if self._generates_isolated_main_node(tube_relations):
                self.nodes[tube.tag] = Node(tube.tag, tube)
                continue
            
            # If we arrive here, then our tube collide with some other tube,
            # hence, we must build an s-node for each potential collision. 
            
            for tag, relation in tube_relations.items():
                if tag == tube.tag or relation is None: continue
                    
                if type(relation) is Overlapping:                    
                    Vs = self._generate_subnode_id(tube.tag, tag, 's')
                    Ve = self._generate_subnode_id(tube.tag, tag, 'e')
                    
                    self.nodes[Vs] = Node(Vs, tube, relation.sframe)
                    self.nodes[Ve] = Node(Ve, tube, relation.eframe)
                    
                    # Insert the direct edge between the nodes 
                    weight = relation.eframe - relation.sframe
                    edges_list.append((Vs, Ve, weight))
                    
                    # Insert undirected edges with colliding tube
                    Us = self._generate_subnode_id(tag, tube.tag, 's')
                    Ue = self._generate_subnode_id(tag, tube.tag, 'e')
                    
                    edge_Vs_Us = (Vs, Us, -1)
                    edge_Us_Vs = (Us, Vs, -1)
                    edge_Ve_Ue = (Ve, Ue, -1)
                    edge_Ue_Ve = (Ue, Ve, -1)
                    
                    if edge_Vs_Us not in edges_list: edges_list.append(edge_Vs_Us)
                    if edge_Us_Vs not in edges_list: edges_list.append(edge_Us_Vs)
                    if edge_Ve_Ue not in edges_list: edges_list.append(edge_Ve_Ue)
                    if edge_Ue_Ve not in edges_list: edges_list.append(edge_Ue_Ve)
                    
                elif type(relation) is Intersection:

                    subnode_id = self._generate_subnode_id(tube.tag, tag)
                    self.nodes[subnode_id] = Node(subnode_id, tube, relation.frame)
                    
                    # add an edge in both directions 
                    opposite_node_id = self._generate_subnode_id(tag, tube.tag)
                    edge1 = (subnode_id, opposite_node_id, 1)
                    edge2 = (opposite_node_id, subnode_id, 1)
                                        
                    if edge1 not in edges_list:
                        edges_list.append(edge1)
                    if edge2 not in edges_list:
                        edges_list.append(edge2)
            
        self.edges = edges_list

        for v in self.nodes:
            self.A[v] = {}
            for u in self.nodes:
                self.A[v][u] = 0        

        for v, u, w in edges_list:
            self.A[v][u] = w


    def _generates_isolated_main_node(self, tube_relations):
        """ If the tube has irrilevant relations with all 
            other tubes, then it can be abstracted as an isolated
            main-node.
        """
        return all([ r is None for r in tube_relations.values() ])
        

    def _generate_subnode_id(self, ptag, ctag, endpoint=''):
        """ 
        """
        assert endpoint in ['s', 'e', '']
        tmp = '-' + endpoint if endpoint in ['s', 'e'] else endpoint
        return f'{ptag}-{ctag}{tmp}'
        
